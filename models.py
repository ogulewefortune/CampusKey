# Import SQLAlchemy - Flask extension for database ORM (Object-Relational Mapping)
# SQLAlchemy allows us to interact with databases using Python objects instead of SQL queries
from flask_sqlalchemy import SQLAlchemy

# Import UserMixin - Flask-Login mixin that provides default implementations for user authentication
# UserMixin adds methods like is_authenticated, is_active, get_id() required by Flask-Login
from flask_login import UserMixin

# Import datetime - Python module for working with dates and times
# Used for timestamp fields like created_at, updated_at, expires_at, etc.
from datetime import datetime

# Import pyotp - Python library for generating and verifying TOTP (Time-based One-Time Password) codes
# Used for OTP-based authentication (like Google Authenticator)
import pyotp


# Create SQLAlchemy database instance
# This is a central object that will be initialized with the Flask app
# All database models will inherit from db.Model
# Database operations (queries, commits) are done through db.session
db = SQLAlchemy()


# User model - Represents a user account in the system (admin, professor, or student)
# Inherits from UserMixin (for Flask-Login) and db.Model (for SQLAlchemy)
# UserMixin provides: is_authenticated, is_active, is_anonymous, get_id() methods
# db.Model provides: database table mapping, query methods, etc.
class User(UserMixin, db.Model):
    # Primary key - Unique identifier for each user record
    # db.Integer: Stores integer values
    # primary_key=True: Marks this as the primary key (auto-increments)
    # Auto-generated by database, cannot be null
    id = db.Column(db.Integer, primary_key=True)
    
    # Username field - Unique identifier for login and user identification
    # db.String(80): Text field with maximum 80 characters
    # unique=True: Ensures no two users can have the same username (database constraint)
    # nullable=False: This field is required and cannot be empty/null
    # Used for authentication and user identification throughout the application
    username = db.Column(db.String(80), unique=True, nullable=False)
    
    # Email field - Email address (optional, not used for authentication)
    # db.String(120): Text field with maximum 120 characters (standard email length)
    # nullable=True: This field is optional and can be null/empty
    # Note: Email is NOT stored during user creation - only used temporarily for sending verification codes
    # This field exists for legacy/display purposes only
    email = db.Column(db.String(120), nullable=True)  # Optional - only for legacy/display purposes
    
    # Phone number field - Phone number for SMS OTP authentication (future feature)
    # db.String(20): Text field with maximum 20 characters (supports international formats)
    # nullable=True: This field is optional and can be null/empty
    # Format: Should use E.164 format (e.g., +1234567890)
    # Currently not actively used, reserved for future SMS authentication feature
    phone_number = db.Column(db.String(20), nullable=True)  # Phone number for SMS OTP
    
    # Role field - User's role in the system (determines access permissions)
    # db.String(20): Text field with maximum 20 characters
    # nullable=False: This field is required and cannot be empty/null
    # Possible values: 'admin', 'professor', 'student'
    # Used for role-based access control (RBAC) throughout the application
    # Admin: Full system access, can manage users, view all logs
    # Professor: Can manage courses and assign grades to students
    # Student: Can view their own grades and enrolled courses
    role = db.Column(db.String(20), nullable=False)  # student, professor, admin
    
    # OTP secret - Secret key for generating TOTP (Time-based One-Time Password) codes
    # db.String(32): Text field with 32 characters (base32 encoded secret)
    # default=pyotp.random_base32: Automatically generates a random 32-character base32 string
    # This secret is used with pyotp library to generate and verify OTP codes
    # Generated once when user is created, stored securely in database
    # Used by verify_otp() method to verify TOTP codes from authenticator apps
    otp_secret = db.Column(db.String(32), default=pyotp.random_base32)
    
    # Created timestamp - Records when the user account was created
    # db.DateTime: Stores date and time values
    # default=datetime.utcnow: Automatically sets to current UTC time when record is created
    # Note: datetime.utcnow is passed as function reference (not called), so it's evaluated at creation time
    # UTC time is used to avoid timezone issues across different servers
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    # Method to verify TOTP (Time-based One-Time Password) codes
    # self: Reference to the User instance calling this method
    # token: The OTP code to verify (usually 6 digits from authenticator app)
    # Returns: Boolean - True if token is valid, False if invalid or expired
    # Uses pyotp library to create a TOTP instance with user's secret and verify the token
    # TOTP codes are time-based and expire after a short period (usually 30 seconds)
    def verify_otp(self, token):
        # Create TOTP instance using user's stored secret key
        # TOTP generates codes based on current time and secret key
        # verify() checks if the provided token matches the current valid code
        # Returns True if valid, False if invalid or expired
        return pyotp.TOTP(self.otp_secret).verify(token)


# LoginAttempt model - Logs all login attempts (successful and failed) for security auditing
# Inherits from db.Model to become a database table
# Used for security monitoring, intrusion detection, and audit trails
# Records every authentication attempt regardless of success or failure
class LoginAttempt(db.Model):
    # Primary key - Unique identifier for each login attempt record
    # db.Integer: Stores integer values
    # primary_key=True: Marks this as the primary key (auto-increments)
    # Auto-generated by database, cannot be null
    id = db.Column(db.Integer, primary_key=True)
    
    # User ID foreign key - Links to the User who attempted login (if user exists)
    # db.Integer: Stores integer values
    # db.ForeignKey('user.id'): Creates foreign key relationship to User.id
    # nullable: Can be None/null (for failed login attempts where user doesn't exist)
    # If login fails because user doesn't exist, this will be null
    # If login succeeds or fails for existing user, this will contain user's ID
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    
    # Username field - Username that was attempted (even if user doesn't exist)
    # db.String(80): Text field with maximum 80 characters
    # nullable=False: This field is required and cannot be empty/null
    # Always stored, even for failed attempts, to track brute force attacks
    # Used for security analysis and identifying suspicious login patterns
    username = db.Column(db.String(80), nullable=False)
    
    # Authentication method - Method used for login attempt
    # db.String(20): Text field with maximum 20 characters
    # nullable=False: This field is required and cannot be empty/null
    # Possible values: 'otp', 'email', 'biometric', 'rfid', 'password'
    # 'otp': Time-based OTP from authenticator app
    # 'email': Email verification code
    # 'biometric': Biometric authentication (fingerprint, face recognition)
    # 'rfid': RFID card authentication
    # 'password': Traditional password authentication
    method = db.Column(db.String(20), nullable=False)  # otp, biometric, rfid, password
    
    # Status field - Result of the login attempt
    # db.String(10): Text field with maximum 10 characters
    # nullable=False: This field is required and cannot be empty/null
    # Possible values: 'success', 'failed'
    # 'success': Login attempt was successful, user authenticated
    # 'failed': Login attempt failed (wrong credentials, expired code, etc.)
    # Used for security monitoring and identifying failed login patterns
    status = db.Column(db.String(10), nullable=False)  # success, failed
    
    # IP address field - IP address of the client making the login attempt
    # db.String(45): Text field with 45 characters (supports IPv4 and IPv6)
    # nullable: Can be None/null (if IP cannot be determined)
    # Captured from Flask's request.remote_addr
    # Used for security analysis, detecting location changes, identifying suspicious IPs
    # IPv4 format: "192.168.1.1" (15 chars max)
    # IPv6 format: "2001:0db8:85a3:0000:0000:8a2e:0370:7334" (39 chars max)
    ip_address = db.Column(db.String(45))
    
    # User agent field - Browser/client information from HTTP request
    # db.Text: Text field without length limit (can be very long)
    # nullable: Can be None/null (if user agent header not present)
    # Captured from Flask's request.headers.get('User-Agent')
    # Contains browser name, version, operating system, device information
    # Example: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36..."
    # Used for security analysis, detecting device changes, identifying suspicious clients
    user_agent = db.Column(db.Text)
    
    # Timestamp field - When the login attempt occurred
    # db.DateTime: Stores date and time values
    # default=datetime.utcnow: Automatically sets to current UTC time when record is created
    # Records exact time of login attempt for chronological analysis
    # Used for security monitoring, identifying attack patterns, audit trails
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Relationship to User model - Allows accessing User from LoginAttempt
    # db.relationship('User'): Creates relationship to User model
    # backref=db.backref('login_attempts', lazy=True): Creates reverse relationship
    # This allows: login_attempt.user (access User) and user.login_attempts (access all attempts)
    # lazy=True: Related objects are loaded only when accessed (lazy loading for performance)
    # This relationship is optional (user_id can be null for failed attempts)
    user = db.relationship('User', backref=db.backref('login_attempts', lazy=True))


# ActiveSession model - Tracks active user sessions for security monitoring
# Inherits from db.Model to become a database table
# Used to monitor active sessions, detect multiple concurrent logins, track session activity
# Sessions expire after 2 hours of inactivity (handled in auth.py)
class ActiveSession(db.Model):
    # Primary key - Unique identifier for each active session record
    # db.Integer: Stores integer values
    # primary_key=True: Marks this as the primary key (auto-increments)
    # Auto-generated by database, cannot be null
    id = db.Column(db.Integer, primary_key=True)
    
    # User ID foreign key - Links to the User who owns this session
    # db.Integer: Stores integer values
    # db.ForeignKey('user.id'): Creates foreign key relationship to User.id
    # nullable=False: This field is required and cannot be null (session must belong to a user)
    # Every active session must be associated with a user account
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    
    # Session ID field - Unique identifier for the Flask session
    # db.String(128): Text field with maximum 128 characters
    # nullable=False: This field is required and cannot be empty/null
    # Should match Flask's session.sid (session identifier)
    # Used to track and manage individual user sessions
    # Multiple sessions can exist for the same user (different devices/browsers)
    session_id = db.Column(db.String(128), nullable=False)
    
    # Login time field - When the session started (when user logged in)
    # db.DateTime: Stores date and time values
    # default=datetime.utcnow: Automatically sets to current UTC time when record is created
    # Set once when session is created, does NOT change after initial creation
    # Used to track session duration and identify long-running sessions
    login_time = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Last activity field - Last time user activity was recorded for this session
    # db.DateTime: Stores date and time values
    # default=datetime.utcnow: Automatically sets to current UTC time when record is created
    # Should be updated periodically (on each request) to track recent activity
    # Used to determine if session is still active (expires after 2 hours of inactivity)
    # Updated in auth.py's track_session_activity() function
    last_activity = db.Column(db.DateTime, default=datetime.utcnow)
    
    # IP address field - IP address of the client for this session
    # db.String(45): Text field with 45 characters (supports IPv4 and IPv6)
    # nullable: Can be None/null (if IP cannot be determined)
    # Captured from Flask's request.remote_addr when session is created
    # Used for security monitoring, detecting location changes, identifying suspicious sessions
    # Can help detect if session is being used from unexpected location
    ip_address = db.Column(db.String(45))
    
    # User agent field - Browser/client information for this session
    # db.Text: Text field without length limit (can be very long)
    # nullable: Can be None/null (if user agent header not present)
    # Captured from Flask's request.headers.get('User-Agent') when session is created
    # Contains browser name, version, operating system, device information
    # Used for security monitoring, detecting device changes, identifying suspicious clients
    # Can help detect if session is being used from unexpected device/browser
    user_agent = db.Column(db.Text)
    
    # Relationship to User model - Allows accessing User from ActiveSession
    # db.relationship('User'): Creates relationship to User model
    # backref=db.backref('active_sessions', lazy=True): Creates reverse relationship
    # This allows: active_session.user (access User) and user.active_sessions (access all sessions)
    # lazy=True: Related objects are loaded only when accessed (lazy loading for performance)
    # Used to get user information from session and list all active sessions for a user
    user = db.relationship('User', backref=db.backref('active_sessions', lazy=True))


# EmailVerificationCode model - Stores email verification codes sent to users for login authentication
# Inherits from db.Model to become a database table
# Used for email-based authentication flow
# Codes expire after 10 minutes and can only be used once
class EmailVerificationCode(db.Model):
    # Primary key - Unique identifier for each verification code record
    # db.Integer: Stores integer values
    # primary_key=True: Marks this as the primary key (auto-increments)
    # Auto-generated by database, cannot be null
    id = db.Column(db.Integer, primary_key=True)
    
    # Email field - Email address where the verification code was sent
    # db.String(120): Text field with maximum 120 characters (standard email length)
    # nullable=False: This field is required and cannot be empty/null
    # Important: This is the email from the form input, NOT from User model
    # Email is not stored in User model - only stored here temporarily for verification
    # Used to send verification code and verify code during login
    email = db.Column(db.String(120), nullable=False)
    
    # Code field - The 6-digit verification code
    # db.String(6): Text field with exactly 6 characters (digits only)
    # nullable=False: This field is required and cannot be empty/null
    # Format: String of 6 digits (e.g., "123456")
    # Generated randomly using generate_verification_code() function in email_service.py
    # Used for email-based authentication - user enters this code to verify identity
    code = db.Column(db.String(6), nullable=False)
    
    # Username field - Username associated with this verification code
    # db.String(80): Text field with maximum 80 characters
    # nullable=False: This field is required and cannot be empty/null
    # Links the verification code to a specific user account
    # Used during login verification to match code with correct user
    # Multiple codes can exist for same username (different emails or times)
    username = db.Column(db.String(80), nullable=False)
    
    # Expires at field - When the verification code expires
    # db.DateTime: Stores date and time values
    # nullable=False: This field is required and cannot be empty/null
    # Set to 10 minutes from creation time (datetime.utcnow() + timedelta(minutes=10))
    # Used to verify code is still valid - codes expire after 10 minutes
    # Check: expires_at > datetime.utcnow() to verify code is still valid
    expires_at = db.Column(db.DateTime, nullable=False)
    
    # Used flag - Whether the verification code has been used
    # db.Boolean: Stores True/False values
    # default=False: Defaults to False (not used) when code is created
    # Set to True after successful login to prevent code reuse
    # Important: Codes can only be used once for security
    # Used to prevent replay attacks and ensure one-time use
    used = db.Column(db.Boolean, default=False)
    
    # Created timestamp - When the verification code was created
    # db.DateTime: Stores date and time values
    # default=datetime.utcnow: Automatically sets to current UTC time when record is created
    # Records when code was generated for audit and debugging purposes
    # Used to track code generation time and identify old unused codes
    created_at = db.Column(db.DateTime, default=datetime.utcnow)


# Course model - Represents a course taught by a professor
# Inherits from db.Model to become a database table
# Used for course management - professors create courses, students enroll through grades
class Course(db.Model):
    # Primary key - Unique identifier for each course record
    # db.Integer: Stores integer values
    # primary_key=True: Marks this as the primary key (auto-increments)
    # Auto-generated by database, cannot be null
    id = db.Column(db.Integer, primary_key=True)
    
    # Course code field - Unique course identifier (e.g., "CS101", "MATH201")
    # db.String(20): Text field with maximum 20 characters
    # unique=True: Ensures no two courses can have the same code (database constraint)
    # nullable=False: This field is required and cannot be empty/null
    # Format: Typically department abbreviation + number (e.g., "CS101", "MATH201", "ENG101")
    # Used as unique identifier for courses throughout the system
    # Displayed in course lists, grade entry forms, student transcripts
    code = db.Column(db.String(20), unique=True, nullable=False)  # e.g., "CS101"
    
    # Course name field - Full descriptive name of the course
    # db.String(200): Text field with maximum 200 characters
    # nullable=False: This field is required and cannot be empty/null
    # Examples: "Introduction to Computer Science", "Calculus I", "English Composition"
    # Used for display purposes and course identification
    # More descriptive than course code, helps users identify courses
    name = db.Column(db.String(200), nullable=False)
    
    # Professor ID foreign key - Links to the User (professor) who teaches this course
    # db.Integer: Stores integer values
    # db.ForeignKey('user.id'): Creates foreign key relationship to User.id
    # nullable=False: This field is required and cannot be null (every course must have a professor)
    # Constraint: User must have role 'professor' (enforced in application logic, not database)
    # Used to associate courses with professors and filter courses by professor
    # Professors can have multiple courses, but each course has one professor
    professor_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    
    # Created timestamp - When the course was created
    # db.DateTime: Stores date and time values
    # default=datetime.utcnow: Automatically sets to current UTC time when record is created
    # Records when course was added to the system for audit purposes
    # Used to track course creation time and identify recently added courses
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Relationship to User model (professor) - Allows accessing professor from Course
    # db.relationship('User'): Creates relationship to User model
    # backref=db.backref('taught_courses', lazy=True): Creates reverse relationship
    # This allows: course.professor (access User/professor) and user.taught_courses (access all courses)
    # lazy=True: Related objects are loaded only when accessed (lazy loading for performance)
    # Used to get professor information from course and list all courses taught by a professor
    professor = db.relationship('User', backref=db.backref('taught_courses', lazy=True))


# Grade model - Represents a grade assigned to a student for a course
# Inherits from db.Model to become a database table
# Used for grade management - professors assign grades, students view their grades
# Links students, courses, and professors together
class Grade(db.Model):
    # Primary key - Unique identifier for each grade record
    # db.Integer: Stores integer values
    # primary_key=True: Marks this as the primary key (auto-increments)
    # Auto-generated by database, cannot be null
    id = db.Column(db.Integer, primary_key=True)
    
    # Student ID foreign key - Links to the User (student) who received this grade
    # db.Integer: Stores integer values
    # db.ForeignKey('user.id'): Creates foreign key relationship to User.id
    # nullable=False: This field is required and cannot be null (every grade must belong to a student)
    # Constraint: User must have role 'student' (enforced in application logic, not database)
    # Used to associate grades with students and filter grades by student
    # Students can have multiple grades (one per course), but each grade belongs to one student
    student_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    
    # Course ID foreign key - Links to the Course this grade is for
    # db.Integer: Stores integer values
    # db.ForeignKey('course.id'): Creates foreign key relationship to Course.id
    # nullable=False: This field is required and cannot be null (every grade must belong to a course)
    # Used to associate grades with courses and filter grades by course
    # Courses can have multiple grades (one per student), but each grade belongs to one course
    course_id = db.Column(db.Integer, db.ForeignKey('course.id'), nullable=False)
    
    # Grade value field - Letter grade (e.g., "A+", "A", "A-", "B+", "B", etc.)
    # db.String(5): Text field with maximum 5 characters (covers "A+" format)
    # nullable=False: This field is required and cannot be empty/null
    # Format: Letter grade with optional +/- modifier
    # Examples: "A+", "A", "A-", "B+", "B", "B-", "C+", "C", "D", "F"
    # Used for display purposes and grade reporting
    # More readable than percentage, standard format for academic transcripts
    grade_value = db.Column(db.String(5), nullable=False)  # A+, A, A-, B+, etc.
    
    # Percentage field - Numeric grade percentage (0-100)
    # db.Float: Stores floating-point decimal numbers
    # nullable=False: This field is required and cannot be null
    # Range: Typically 0.0 to 100.0 (can exceed 100 for extra credit)
    # Used for GPA calculations, grade comparisons, and statistical analysis
    # More precise than letter grade, allows for mathematical operations
    percentage = db.Column(db.Float, nullable=False)  # 0-100
    
    # Professor ID foreign key - Links to the User (professor) who assigned this grade
    # db.Integer: Stores integer values
    # db.ForeignKey('user.id'): Creates foreign key relationship to User.id
    # nullable=False: This field is required and cannot be null (every grade must have a professor)
    # Note: Different foreign key from student_id (both point to User model but represent different roles)
    # Constraint: User must have role 'professor' (enforced in application logic, not database)
    # Used to track who assigned the grade and filter grades by professor
    # Professors can assign multiple grades, but each grade has one professor
    professor_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    
    # Created timestamp - When the grade was first created
    # db.DateTime: Stores date and time values
    # default=datetime.utcnow: Automatically sets to current UTC time when record is created
    # Set once when grade is created, does NOT change on updates
    # Used to track when grade was originally assigned for audit purposes
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Updated timestamp - When the grade was last modified
    # db.DateTime: Stores date and time values
    # default=datetime.utcnow: Automatically sets to current UTC time when record is created
    # onupdate=datetime.utcnow: Automatically updates to current UTC time whenever record is modified
    # Updated automatically by SQLAlchemy whenever any field in the record changes
    # Used to track grade modification history and identify recently updated grades
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationship to User model (student) - Allows accessing student from Grade
    # db.relationship('User', foreign_keys=[student_id]): Creates relationship using student_id foreign key
    # backref=db.backref('grades', lazy=True): Creates reverse relationship on User model
    # This allows: grade.student (access User/student) and user.grades (access all grades for student)
    # foreign_keys=[student_id]: Specifies which foreign key to use (since Grade has two User foreign keys)
    # lazy=True: Related objects are loaded only when accessed (lazy loading for performance)
    # Used to get student information from grade and list all grades for a student
    student = db.relationship('User', foreign_keys=[student_id], backref=db.backref('grades', lazy=True))
    
    # Relationship to Course model - Allows accessing course from Grade
    # db.relationship('Course'): Creates relationship to Course model
    # backref=db.backref('grades', lazy=True): Creates reverse relationship on Course model
    # This allows: grade.course (access Course) and course.grades (access all grades for course)
    # lazy=True: Related objects are loaded only when accessed (lazy loading for performance)
    # Used to get course information from grade and list all grades for a course
    course = db.relationship('Course', backref=db.backref('grades', lazy=True))
    
    # Relationship to User model (professor) - Allows accessing professor from Grade
    # db.relationship('User', foreign_keys=[professor_id]): Creates relationship using professor_id foreign key
    # foreign_keys=[professor_id]: Specifies which foreign key to use (since Grade has two User foreign keys)
    # No backref: Professor relationship doesn't create reverse relationship (to avoid confusion)
    # This allows: grade.professor (access User/professor who assigned the grade)
    # Used to get professor information from grade and identify who assigned each grade
    professor = db.relationship('User', foreign_keys=[professor_id])
